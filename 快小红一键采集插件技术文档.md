# 快小红一键采集插件 - 技术文档

## 📖 文档目录

1. [插件简介](#插件简介)
2. [工作原理（用生活例子说明）](#工作原理)
3. [数据采集流程](#数据采集流程)
4. [飞书绑定与数据同步](#飞书绑定与数据同步)
5. [如果要复刻：技术架构设计](#技术架构设计)
6. [核心代码模块详解](#核心代码模块详解)

---

## 插件简介

### 这个插件是干什么的？

简单来说，这个插件就像一个**智能小助手**，帮你在小红书上"抄笔记"。

想象一下：
- 你看到一个博主发了100篇笔记，想把所有笔记信息都记录下来
- 或者你看到一篇很棒的笔记，想保存它的标题、图片、点赞数等信息
- 手动复制粘贴太累了！

这个插件就是帮你**自动完成这些记录工作**，还能直接把数据整理好，同步到飞书表格里。

### 它能做什么？

这个插件有**三大核心功能**：

1. **单篇笔记采集** 📝
   - 打开任意小红书笔记详情页
   - 点击"开始采集"
   - 自动获取：标题、作者、正文、图片、视频、点赞数、收藏数、评论数、发布时间等

2. **博主全部笔记采集** 📚
   - 打开博主的主页
   - 点击"开始采集"
   - 自动滚动页面，采集这个博主的所有笔记信息

3. **博主信息采集** 👤
   - 打开博主的主页
   - 点击"开始采集"
   - 自动获取：博主名称、头像、小红书号、简介、粉丝数等

所有数据都可以：
- ✅ 导出成 Excel 文件
- ✅ 同步到飞书多维表格
- ✅ 下载笔记的图片和视频

---

## 工作原理

### 用生活例子来理解

把这个插件想象成一个**图书馆管理员**的工作流程：

#### 1️⃣ 你（用户）的角色
- 你是来图书馆找资料的读者
- 你告诉管理员："帮我把这个作家的所有书籍信息都记录下来"

#### 2️⃣ 插件侧边栏（sidebar）的角色
- 这是图书馆的**服务台**
- 你在服务台填写需求表、查看采集结果、导出数据

#### 3️⃣ Content Script（content.js）的角色
- 这是一个**卧底特工**，混进了小红书网页内部
- 它能看到网页上的所有内容（就像能看到书架上的所有书）
- 它能模拟人的行为：滚动页面、点击按钮、读取文字

#### 4️⃣ Background Script（background.js）的角色
- 这是**对讲机中转站**
- 服务台和卧底特工通过对讲机通话，中转站负责转接消息

#### 5️⃣ 飞书 API 的角色
- 这是一个**仓库管理系统**
- 采集到的数据最终存放在飞书的"仓库"（多维表格）里

### 完整的工作流程（以采集博主笔记为例）

```
第1步：你在侧边栏点击"开始采集"按钮
       ↓
第2步：侧边栏通过"对讲机"发消息："开始采集！"
       ↓
第3步：卧底特工（content.js）收到消息，开始行动：
       - 滚动页面到顶部
       - 慢慢往下滚动，让网页加载更多内容
       - 一边滚动一边"拍照记录"：
         * 笔记标题是什么？
         * 图片链接是什么？
         * 点赞数是多少？
       ↓
第4步：采集完成后，特工把数据通过"对讲机"发回给侧边栏
       ↓
第5步：侧边栏把数据整理好，显示在界面上
       ↓
第6步（可选）：你点击"同步飞书"
       - 侧边栏把数据打包成JSON格式
       - 调用飞书API，把数据存到表格里
```

---

## 数据采集流程

### 采集的核心技术：DOM 解析

#### 什么是 DOM？
DOM 就像网页的"骨架结构"。每个网页都是由一个个"盒子"（HTML元素）组成的。

举个例子，小红书的一篇笔记在网页代码里长这样：

```html
<div class="note-card">
  <img src="图片链接.jpg">
  <div class="title">这是笔记标题</div>
  <div class="author">作者名</div>
  <div class="likes">1000</div>
</div>
```

插件要做的就是**找到这些"盒子"，把里面的内容读出来**。

### 采集流程详解

#### 方式1：博主全部笔记采集（滚动加载）

小红书用的是"懒加载"技术，就像刷抖音一样，滚动到哪里才加载到哪里。

```javascript
// 核心代码逻辑（简化版）
async function captureLinks() {
  let links = [];  // 存放采集到的笔记
  let scrollPosition = 0;  // 当前滚动位置
  
  // 循环滚动，直到没有新内容
  while (还有新内容) {
    // 1. 获取当前页面上的所有笔记卡片
    const cards = document.querySelectorAll('.note-card');
    
    // 2. 遍历每张卡片，提取信息
    cards.forEach(card => {
      const title = card.querySelector('.title').textContent;
      const image = card.querySelector('img').src;
      const author = card.querySelector('.author').textContent;
      const likes = card.querySelector('.likes').textContent;
      
      links.push({ title, image, author, likes });
    });
    
    // 3. 滚动页面，加载更多内容
    window.scrollTo(0, scrollPosition + 500);
    scrollPosition += 500;
    
    // 4. 等待新内容加载完成
    await sleep(1500);
  }
  
  return links;
}
```

**关键技巧：**
- 使用 `document.querySelectorAll()` 查找所有笔记卡片
- 使用 `querySelector()` 在卡片内查找具体元素
- 使用 `scrollTo()` 模拟人的滚动行为
- 使用 `setTimeout()` 等待页面加载

#### 方式2：单篇笔记采集（精确定位）

打开笔记详情页后，直接读取页面上的信息。

```javascript
// 核心代码逻辑（简化版）
async function extractNoteData() {
  // 找到笔记的主容器
  const noteContainer = document.querySelector('.note-content');
  
  // 提取各种信息
  const title = noteContainer.querySelector('.title').textContent;
  const author = noteContainer.querySelector('.author').textContent;
  const content = noteContainer.querySelector('.note-text').textContent;
  const likes = noteContainer.querySelector('.like-wrapper .count').textContent;
  
  // 提取所有图片
  const images = noteContainer.querySelectorAll('img');
  const imageUrls = Array.from(images).map(img => img.src);
  
  return {
    title, author, content, likes, imageUrls
  };
}
```

**关键技巧：**
- 先找到"主容器"，避免采集到其他笔记的数据
- 使用多个选择器作为备选方案（因为小红书可能改版）
- 处理特殊情况：视频笔记、live图等

---

## 飞书绑定与数据同步

### 飞书多维表格是什么？

飞书多维表格就像一个**在线 Excel**，但更强大：
- 可以存储大量数据
- 可以通过 API 程序化操作
- 可以多人协作

### 为什么需要"中间人"Coze？

直接调用飞书 API 很复杂，需要处理认证、权限等问题。

这个插件使用了 **Coze 平台的工作流**作为"中间人"：

```
插件 → Coze工作流 → 飞书API → 飞书表格
```

**好处：**
- 插件只需要发送数据给 Coze
- Coze 自动处理飞书认证、数据写入等复杂操作
- 还可以验证订单号，防止滥用

### 数据同步流程详解

#### 第1步：用户配置

在"配置飞书"页面填写：
- **订单号**：验证用户身份
- **多维表格授权码（basetoken）**：访问飞书表格的凭证
- **表格链接**：数据要存到哪个表格

这些配置保存在浏览器的 `localStorage` 里。

#### 第2步：数据格式化

插件把采集到的数据转换成飞书要求的格式：

```javascript
// 原始采集数据
const note = {
  title: "小红书笔记标题",
  author: "作者名",
  likes: 1000,
  url: "https://..."
};

// 转换成飞书格式
const records = [{
  fields: {
    "标题": "小红书笔记标题",
    "博主": "作者名",
    "点赞数": 1000,
    "笔记链接": {
      "link": "https://...",
      "text": "查看原文"
    }
  }
}];

// 转成 JSON 字符串
const body = JSON.stringify({ records });
```

#### 第3步：调用 Coze API

```javascript
fetch('https://api.coze.cn/v1/workflow/run', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer xxx',  // Coze的访问令牌
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    workflow_id: '7550495904676167716',  // 工作流ID
    parameters: {
      ordeid: '你的订单号',
      basetoken: '飞书授权码',
      blogger_noteurl: '表格链接',
      body: body  // 笔记数据
    }
  })
});
```

#### 第4步：Coze 工作流处理

Coze 工作流内部会：
1. 验证订单号是否有效
2. 使用 basetoken 访问飞书表格
3. 把数据写入指定表格
4. 返回结果（成功/失败）

#### 第5步：显示结果

插件收到响应后，解析结果：

```javascript
if (result.add_result && result.ordeid_result) {
  showStatus('同步成功，去表格看看吧');
} else if (!result.ordeid_result) {
  showStatus('订单号不存在或已过期');
} else {
  showStatus('同步出了点问题');
}
```

### 三种同步场景

这个插件有三个不同的 Coze 工作流：

| 功能 | 工作流ID | 表格字段 |
|------|---------|---------|
| 博主笔记采集 | 7550495904676167716 | 博主、标题、点赞数、笔记链接、封面链接 |
| 单篇笔记采集 | 7550495126771449906 | 标题、正文、图片链接、视频链接、点赞数、收藏数、评论数、发布时间、采集时间等 |
| 博主信息采集 | 7550495802553106467 | 博主名称、头像链接、小红书号、简介、粉丝数、主页链接、采集时间 |

---

## 技术架构设计

### 如果你要复刻类似功能，应该怎么搭建？

#### 整体架构图

```
┌─────────────────────────────────────────────────┐
│                   用户界面层                      │
│  ┌──────────────┐  ┌──────────────┐            │
│  │ 侧边栏UI     │  │ 配置页面     │            │
│  │ (sidebar.html)│  │ (config)     │            │
│  └──────────────┘  └──────────────┘            │
└─────────────────────────────────────────────────┘
                     ↕
┌─────────────────────────────────────────────────┐
│                   逻辑控制层                      │
│  ┌──────────────────────────────────────────┐  │
│  │          sidebar.js                       │  │
│  │  - 按钮事件监听                            │  │
│  │  - 数据展示与管理                          │  │
│  │  - 消息发送与接收                          │  │
│  │  - 导出Excel功能                           │  │
│  │  - 飞书同步功能                            │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
                     ↕
┌─────────────────────────────────────────────────┐
│                  消息中转层                       │
│  ┌──────────────────────────────────────────┐  │
│  │      background.js (Service Worker)       │  │
│  │  - 打开侧边栏                              │  │
│  │  - 转发消息                                │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
                     ↕
┌─────────────────────────────────────────────────┐
│                   数据采集层                      │
│  ┌──────────────────────────────────────────┐  │
│  │           content.js                      │  │
│  │  - DOM 解析与数据提取                       │  │
│  │  - 页面滚动控制                            │  │
│  │  - 图片视频链接提取                         │  │
│  │  - 互动数据提取（点赞/收藏/评论）           │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
                     ↕
┌─────────────────────────────────────────────────┐
│                  目标网页层                       │
│  ┌──────────────────────────────────────────┐  │
│  │        小红书网页 DOM                       │  │
│  │  - 笔记卡片元素                            │  │
│  │  - 博主信息元素                            │  │
│  │  - 互动数据元素                            │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
                     ↕
┌─────────────────────────────────────────────────┐
│                  数据存储层                       │
│  ┌──────────────┐  ┌──────────────┐            │
│  │ LocalStorage │  │  Coze API    │            │
│  │  (配置存储)  │  │  (中间层)    │            │
│  └──────────────┘  └──────────────┘            │
│                          ↓                      │
│                    ┌──────────────┐            │
│                    │  飞书多维表格 │            │
│                    └──────────────┘            │
└─────────────────────────────────────────────────┘
```

### 关键技术栈

#### 1. 浏览器插件技术（Chrome Extension）

**核心概念：**
- **Manifest V3**：插件的配置文件，定义权限、脚本等
- **Content Script**：注入到网页的脚本，可以访问 DOM
- **Service Worker**：后台脚本，处理消息、管理状态
- **Side Panel**：侧边栏界面

**必需权限：**
```json
{
  "permissions": [
    "activeTab",      // 访问当前标签页
    "scripting",      // 执行脚本
    "downloads",      // 下载文件
    "storage",        // 存储数据
    "sidePanel"       // 侧边栏
  ],
  "host_permissions": [
    "*://www.xiaohongshu.com/*",  // 访问小红书
    "*://open.feishu.cn/*",       // 访问飞书API
    "*://api.coze.cn/*"           // 访问Coze API
  ]
}
```

#### 2. DOM 解析技术

**核心方法：**
- `document.querySelector()`：查找单个元素
- `document.querySelectorAll()`：查找所有匹配元素
- `document.evaluate()`：XPath 查询（更精确）
- `element.textContent`：获取文本内容
- `element.getAttribute()`：获取属性值

**实战技巧：**
```javascript
// 技巧1：多选择器策略（网站可能改版）
const titleElement = 
  document.querySelector('.title') ||
  document.querySelector('.note-title') ||
  document.querySelector('h1');

// 技巧2：容器内查找（避免误采集）
const noteContainer = document.querySelector('.note-content');
const title = noteContainer.querySelector('.title');

// 技巧3：数组处理
const images = document.querySelectorAll('img');
const imageUrls = Array.from(images).map(img => img.src);
```

#### 3. 异步编程与滚动控制

**核心技术：**
```javascript
// 技巧1：异步等待
async function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// 技巧2：滚动控制
window.scrollTo(0, scrollPosition);
await sleep(1500);  // 等待页面加载

// 技巧3：检测是否还有新内容
let attemptsWithoutNewContent = 0;
if (发现新内容) {
  attemptsWithoutNewContent = 0;
} else {
  attemptsWithoutNewContent++;
}
```

#### 4. 消息通信机制

**插件内部通信：**
```javascript
// sidebar.js 发送消息
chrome.tabs.sendMessage(tabId, {
  action: 'startCapture'
}, response => {
  console.log('收到响应', response);
});

// content.js 接收消息
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'startCapture') {
    captureLinks().then(links => {
      sendResponse({ links });
    });
    return true;  // 保持通道开放
  }
});
```

#### 5. 数据导出技术

**导出 CSV（兼容 Excel）：**
```javascript
// BOM头确保中文正常显示
let csvContent = '\ufeff标题,作者,点赞数\n';

// 处理特殊字符
const title = note.title.replace(/"/g, '""').replace(/,/g, '，');

// 创建下载
const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
const link = document.createElement('a');
link.href = URL.createObjectURL(blob);
link.download = '小红书笔记.csv';
link.click();
```

#### 6. HTTP 请求与 API 集成

**Fetch API：**
```javascript
fetch('https://api.coze.cn/v1/workflow/run', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer xxx',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error(error));
```

---

## 核心代码模块详解

### 文件结构

```
快小红一键采集V1.1.3/
├── manifest.json        # 插件配置文件
├── background.js        # 后台脚本（消息中转）
├── content.js           # 内容脚本（数据采集核心）
├── sidebar.html         # 侧边栏界面
├── sidebar.js           # 侧边栏逻辑（UI控制、数据处理）
├── sidebar.css          # 侧边栏样式
└── images/              # 插件图标
```

### 1. manifest.json - 插件配置文件

**作用：** 这是插件的"身份证"，定义插件的名称、版本、权限等。

```json
{
  "manifest_version": 3,
  "name": "快小红一键采集",
  "version": "1.1.3",
  "permissions": ["activeTab", "scripting", "downloads", "storage", "sidePanel"],
  "host_permissions": [
    "*://www.xiaohongshu.com/*",
    "*://open.feishu.cn/*",
    "*://api.coze.cn/*"
  ],
  "content_scripts": [{
    "matches": ["*://www.xiaohongshu.com/*"],
    "js": ["content.js"]
  }],
  "side_panel": {
    "default_path": "sidebar.html"
  }
}
```

**关键配置：**
- `content_scripts`：在小红书网页上自动注入 content.js
- `host_permissions`：允许访问小红书、飞书、Coze 的域名
- `side_panel`：侧边栏的入口文件

### 2. background.js - 消息中转站

**作用：** 监听插件图标点击，打开侧边栏；转发消息。

```javascript
// 点击插件图标，打开侧边栏
chrome.action.onClicked.addListener((tab) => {
  chrome.sidePanel.open({tabId: tab.id});
});

// 监听消息（可扩展其他功能）
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // 可以在这里添加共享的后台功能
  return true;
});
```

**特点：**
- 非常简洁，主要作用是打开侧边栏
- 可以扩展为处理更复杂的后台任务

### 3. content.js - 数据采集核心（1377行）

**作用：** 这是整个插件最核心的文件，负责从小红书网页上提取数据。

#### 主要函数

##### 3.1 captureLinks() - 采集博主全部笔记

**流程：**
1. 验证是否在博主主页
2. 滚动到顶部重置状态
3. 渐进式滚动加载内容
4. 提取每个笔记卡片的信息
5. 去重并返回结果

**核心代码：**
```javascript
async function captureLinks() {
  // 验证页面
  if (!window.location.href.includes('xiaohongshu.com')) {
    throw new Error('请打开小红书博主主页使用此功能');
  }
  
  const links = [];
  const seen = new Set();  // 去重
  
  let scrollPosition = 0;
  let attemptsWithoutNewContent = 0;
  
  // 渐进式滚动
  while (scrollStep < 50 && attemptsWithoutNewContent < 5) {
    // 获取所有笔记卡片
    const cards = document.querySelectorAll('section, .note-item, .feed-item');
    
    // 提取信息
    for (const card of cards) {
      const linkElement = card.querySelector('a');
      const imageElement = card.querySelector('img');
      const titleElement = card.querySelector('.title');
      const likesElement = card.querySelector('.likes');
      
      const url = linkElement.href;
      const image = imageElement.src;
      const title = titleElement.textContent;
      const likes = likesElement.textContent;
      
      if (!seen.has(url)) {
        links.push({ title, url, image, likes });
        seen.add(url);
      }
    }
    
    // 滚动页面
    scrollPosition += 500;
    window.scrollTo(0, scrollPosition);
    await sleep(1500);
  }
  
  return links;
}
```

##### 3.2 extractNoteData() - 提取单篇笔记数据

**流程：**
1. 验证是否在笔记详情页
2. 找到笔记主容器
3. 提取标题、作者、正文、标签
4. 提取互动数据（点赞、收藏、评论）
5. 提取图片和视频链接
6. 处理发布时间格式

**核心逻辑：**
```javascript
async function extractNoteData() {
  // 找到主容器
  const noteContainer = document.querySelector('.note-content');
  
  // 提取基本信息
  const title = noteContainer.querySelector('.title').textContent;
  const author = noteContainer.querySelector('.author').textContent;
  const content = noteContainer.querySelector('.note-text').textContent;
  
  // 提取标签
  const tagElements = noteContainer.querySelectorAll('.tag');
  const tags = Array.from(tagElements).map(tag => tag.textContent);
  
  // 提取互动数据
  const likes = convertInteractionCount(
    noteContainer.querySelector('.like-wrapper .count').textContent
  );
  
  // 提取图片（排除头像）
  const images = noteContainer.querySelectorAll('img');
  const imageUrls = Array.from(images)
    .filter(img => !img.src.includes('avatar'))
    .map(img => img.src);
  
  // 提取视频
  const videoUrl = await extractVideoUrls();
  
  return {
    title, author, content, tags, likes, imageUrls, videoUrl
  };
}
```

##### 3.3 extractBloggerInfo() - 提取博主信息

**提取内容：**
- 头像链接
- 博主名称
- 博主简介
- 小红书号
- 粉丝数

**核心技巧：**
```javascript
async function extractBloggerInfo() {
  // 使用多个选择器作为备选
  const avatarElements = [
    document.querySelector('.avatar img'),
    document.querySelector('.user-avatar img'),
    document.querySelector('[data-v-86ee68bc=""] img')
  ];
  
  let avatarUrl = '';
  for (const element of avatarElements) {
    if (element && element.src) {
      avatarUrl = element.src;
      break;
    }
  }
  
  // 类似方式提取其他信息
  return {
    avatarUrl, bloggerName, description, bloggerId, followersCount
  };
}
```

##### 3.4 辅助函数

**convertInteractionCount()** - 转换互动数字
```javascript
// "1.2w" → 12000
// "500" → 500
function convertInteractionCount(text) {
  if (text.includes('w') || text.includes('万')) {
    const num = parseFloat(text);
    return Math.round(num * 10000);
  } else if (text.includes('k') || text.includes('千')) {
    const num = parseFloat(text);
    return Math.round(num * 1000);
  } else {
    return parseInt(text);
  }
}
```

**processPublishDate()** - 处理发布时间
```javascript
// "昨天 23:31" → "2024/12/12 23:31"
// "2天前" → "2024/12/11 20:00"
// "12-13" → "2024/12/13 20:00"
function processPublishDate(rawDate) {
  if (rawDate.includes('昨天')) {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    return formatDate(yesterday, 'YYYY/MM/DD HH:mm');
  } else if (rawDate.includes('天前')) {
    const daysAgo = parseInt(rawDate);
    const date = new Date();
    date.setDate(date.getDate() - daysAgo);
    return formatDate(date, 'YYYY/MM/DD HH:mm');
  }
  // ... 更多格式处理
}
```

### 4. sidebar.js - UI控制与业务逻辑（1550行）

**作用：** 处理用户交互、数据展示、导出、同步等所有业务逻辑。

#### 主要功能模块

##### 4.1 初始化与 Tab 切换

```javascript
document.addEventListener('DOMContentLoaded', function() {
  // 初始化Tab切换
  initTabSwitching();
  
  // 初始化按钮事件
  initButtonListeners();
  
  // 加载配置
  loadConfiguration();
});
```

##### 4.2 采集流程控制

**startCapture()** - 开始采集博主笔记
```javascript
function startCapture() {
  // 清空之前的结果
  capturedLinks = [];
  
  // 禁用按钮
  captureBtn.disabled = true;
  captureBtn.textContent = '采集ing...';
  
  // 发送消息到 content.js
  chrome.tabs.sendMessage(tabId, {action: 'startCapture'}, response => {
    if (response.links) {
      capturedLinks = response.links;
      updateCapturedLinksDisplay();
      showStatus(`成功采集到 ${capturedLinks.length} 条笔记`);
    }
    
    // 恢复按钮
    captureBtn.disabled = false;
    captureBtn.textContent = '开始采集';
  });
}
```

##### 4.3 数据展示

**updateCapturedLinksDisplay()** - 展示采集结果
```javascript
function updateCapturedLinksDisplay() {
  const container = document.getElementById('capturedLinksContainer');
  container.innerHTML = '';
  
  capturedLinks.forEach((link, index) => {
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
      <img src="${link.image}">
      <div class="title">${link.title}</div>
      <div class="author">${link.author}</div>
      <div class="likes">点赞数: ${link.likes}</div>
      <button class="delete-button" data-index="${index}">删除</button>
    `;
    container.appendChild(card);
  });
}
```

##### 4.4 导出 Excel

**exportToExcel()** - 导出为 CSV 格式
```javascript
function exportToExcel() {
  // 添加 BOM 头确保中文正常显示
  let csvContent = '\ufeff标题,链接,作者,点赞数,图片链接\n';
  
  capturedLinks.forEach(note => {
    // 处理特殊字符
    const title = note.title.replace(/"/g, '""').replace(/,/g, '，');
    csvContent += `"${title}","${note.url}","${note.author}","${note.likes}","${note.image}"\n`;
  });
  
  // 创建下载
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `小红书笔记_${new Date().toLocaleDateString()}.csv`;
  link.click();
}
```

##### 4.5 同步到飞书

**syncToFeishu()** - 调用 Coze API
```javascript
function syncToFeishu() {
  // 获取配置
  const config = loadConfiguration(true);
  
  // 格式化数据
  const records = capturedLinks.map(note => ({
    fields: {
      "博主": note.author,
      "标题": note.title,
      "点赞数": note.likes,
      "笔记链接": {
        "link": note.url,
        "text": "查看原文"
      },
      "封面链接": note.image
    }
  }));
  
  const body = JSON.stringify({ records });
  
  // 调用 Coze API
  fetch('https://api.coze.cn/v1/workflow/run', {
    method: 'POST',
    headers: {
      'Authorization': 'Bearer sat_xxx',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      workflow_id: '7550495904676167716',
      parameters: {
        ordeid: config.ordeid,
        basetoken: config.basetoken,
        blogger_noteurl: config.blogger_noteurl,
        body: body
      }
    })
  })
  .then(response => response.json())
  .then(data => {
    const result = JSON.parse(data.data);
    if (result.add_result && result.ordeid_result) {
      showStatus('同步成功');
    } else {
      showStatus('同步失败');
    }
  });
}
```

##### 4.6 配置管理

**saveConfiguration()** - 保存配置到本地
```javascript
function saveConfiguration() {
  const config = {
    ordeid: document.getElementById('ordeid').value,
    basetoken: document.getElementById('basetoken').value,
    knowledgeurl: document.getElementById('knowledgeurl').value,
    blogger_noteurl: document.getElementById('blogger_noteurl').value,
    bloggerurl: document.getElementById('bloggerurl').value
  };
  
  localStorage.setItem('feishuConfig', JSON.stringify(config));
  showStatus('配置已保存');
}
```

##### 4.7 下载图片视频

**downloadAllMedia()** - 验证订单号并下载
```javascript
async function downloadAllMedia() {
  // 1. 验证订单号
  const response = await fetch('https://api.coze.cn/v1/workflow/run', {
    method: 'POST',
    body: JSON.stringify({
      workflow_id: '7550648911973105664',
      parameters: { ordeid: config.ordeid }
    })
  });
  
  const data = await response.json();
  const result = JSON.parse(data.data);
  
  if (!result.ordeid_result) {
    showStatus('订单号不存在或已过期');
    return;
  }
  
  // 2. 下载文件
  mediaUrls.forEach((url, index) => {
    chrome.downloads.download({
      url: url,
      filename: `${noteTitle}_media_${index + 1}.jpg`,
      saveAs: false
    });
  });
}
```

### 5. sidebar.html - 用户界面

**作用：** 定义侧边栏的界面结构。

**核心结构：**
```html
<div class="container">
  <!-- 顶部标题 -->
  <div class="header">快小红一键采集</div>
  
  <!-- 状态提示 -->
  <div id="status"></div>
  
  <!-- Tab切换 -->
  <div class="tabs">
    <button id="singleCaptureTab">单篇笔记</button>
    <button id="captureTab">博主笔记</button>
    <button id="bloggerInfoTab">博主信息</button>
    <button id="configTab">配置飞书</button>
  </div>
  
  <!-- 内容区域 -->
  <div class="tab-content">
    <!-- 单篇笔记采集 -->
    <div id="singleCaptureContent">
      <button id="startSingleCaptureBtn">开始采集</button>
      <div id="singleCapturedNotesContainer"></div>
    </div>
    
    <!-- 博主笔记采集 -->
    <div id="captureContent">
      <button id="startCaptureBtn">开始采集</button>
      <div id="capturedLinksContainer"></div>
    </div>
    
    <!-- 配置页面 -->
    <div id="configContent">
      <input id="ordeid" placeholder="订单号">
      <input id="basetoken" placeholder="授权码">
      <button id="saveConfigBtn">保存配置</button>
    </div>
  </div>
</div>
```

---

## 复刻建议

### 如果你要开发类似功能，建议的步骤：

#### 第1步：搭建基础框架（1-2天）

1. 创建 Chrome 插件项目结构
2. 编写 manifest.json，配置权限
3. 创建侧边栏界面（HTML + CSS）
4. 实现基本的消息通信（background ↔ sidebar ↔ content）

#### 第2步：实现数据采集（3-5天）

1. 研究目标网站的 DOM 结构（用浏览器开发者工具）
2. 编写 content.js，实现单个元素的数据提取
3. 实现滚动加载逻辑
4. 处理各种边界情况（视频、live图、特殊格式等）

#### 第3步：UI 与数据展示（2-3天）

1. 实现采集结果的卡片展示
2. 添加删除、清空等管理功能
3. 实现配置页面
4. 添加状态提示和错误处理

#### 第4步：数据导出（1-2天）

1. 实现导出为 CSV 格式
2. 处理中文编码问题（BOM头）
3. 添加下载图片视频功能

#### 第5步：API 集成（2-3天）

1. 选择数据存储方案（飞书/Notion/Airtable等）
2. 研究 API 文档，实现认证
3. 实现数据格式转换
4. 实现同步功能

#### 第6步：测试与优化（2-3天）

1. 测试各种场景（不同页面、不同数据）
2. 优化性能（减少滚动次数、并发请求）
3. 添加错误处理和用户提示
4. 编写使用文档

### 技术难点与解决方案

#### 难点1：网页DOM结构变化

**问题：** 目标网站改版后，选择器失效。

**解决方案：**
- 使用多选择器策略（备选方案）
- 使用更通用的选择器（如 `[class*="note"]`）
- 定期维护更新

#### 难点2：滚动加载的控制

**问题：** 如何判断已经加载到底部？

**解决方案：**
- 记录连续N次滚动没有新内容
- 设置最大滚动次数
- 监听 `scroll` 事件判断是否到底

#### 难点3：数据去重

**问题：** 同一条笔记被采集多次。

**解决方案：**
- 使用 `Set` 数据结构存储已采集的 URL
- 每次采集前检查是否存在

#### 难点4：中文编码问题

**问题：** 导出 CSV 后中文乱码。

**解决方案：**
- 在 CSV 开头添加 BOM 头：`\ufeff`
- 设置正确的 MIME 类型：`text/csv;charset=utf-8`

#### 难点5：视频链接提取

**问题：** 视频链接不直接显示在 DOM 中。

**解决方案：**
- 监听网络请求（`performance.getEntriesByType('resource')`）
- 查找 video 元素的 src 属性
- 区分真正的视频和 live 图

---

## 总结

### 这个插件的核心价值

1. **自动化采集**：解放双手，提高效率
2. **结构化数据**：采集的数据格式规范，易于分析
3. **多平台同步**：数据可以存储到飞书，方便团队协作
4. **扩展性强**：可以轻松扩展到其他平台（抖音、快手等）

### 适用场景

- 🎯 竞品分析：采集竞争对手的笔记数据
- 📊 数据研究：分析爆款笔记的特征
- 📝 内容运营：批量保存灵感素材
- 👥 博主调研：研究KOL的内容策略

### 法律与合规提醒

⚠️ **重要提示：**
- 采集的数据仅供个人学习研究使用
- 不得用于商业目的
- 尊重原作者的版权
- 遵守平台的使用条款

---

## 附录：相关资源

### Chrome 插件开发文档
- [Chrome Extension 官方文档](https://developer.chrome.com/docs/extensions/)
- [Manifest V3 迁移指南](https://developer.chrome.com/docs/extensions/mv3/intro/)

### 飞书开发文档
- [飞书开放平台](https://open.feishu.cn/)
- [多维表格 API](https://open.feishu.cn/document/ukTMukTMukTM/uUDN04SN0QjL1QDN/overview)

### Coze 工作流
- [Coze 平台](https://www.coze.cn/)

### 其他工具
- [正则表达式测试](https://regex101.com/)
- [JSON 格式化](https://jsonformatter.org/)

---

**文档版本：** V1.0  
**最后更新：** 2025-01-03  
**作者：** AI 助手  

如有问题或建议，欢迎交流！🎉

